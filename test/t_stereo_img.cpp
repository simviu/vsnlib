/*
   Author: Sherman Chen
   Create Time: 2022-07-05
   Email: schen@simviu.com
   Copyright(c): Simviu Inc.
   Website: https://www.simviu.com
 */

#include "vsn/vsnTest.h"
#include "vsn/ocv_hlpr.h"
#include "vsn/vsnLibCv.h"

#include <filesystem>
#include <opencv2/ximgproc/disparity_filter.hpp>
#include <opencv2/ccalib/omnidir.hpp>

using namespace vsn;
using namespace ut;
using namespace test;
using namespace cv;

namespace
{
}
#define VIS_MULT 8
#define DOWNSCALE 1
#define MAX_DISPARITY 128
#define WIN_SIZE_SGBM 10
#define SMOOTHING_FACTOR 1
#define MAX_X_GRAD 63

#define LAMBDA 8000
#define SIGMA 2

//----
namespace{
    struct LCfg{
        string sf_L = "pair/L.jpg";
        string sf_R = "pair/R.jpg";
        string sf_camc    = "cfg/cam.yml";
        string sf_stereoc = "cfg/stereo.json";
        //-----
        double baseline = 0.30;
    }; LCfg lc_;

}

//----------
// ref:
//   https://answers.opencv.org/question/223280/calculating-depth-with-ptrstereosgbm-black-bar-on-image/
bool test_LR(const Img& imL, const Img& imR)
{
    auto p_vo = VO::create();
    auto& vo = *p_vo;
    if (!vo.cfg_.load(lc_.sf_stereoc))
        return false;
    CamCfg camc;
    if (!camc.load(lc_.sf_camc))
        return false;
    vo.cfg_.camc = camc;

    //-------
    // run
    //-------
    vo.onImg(imL, imR);

    //----
    vsn::show_loop();    

    return true;
};

//---------------------------
bool test_LR_omnidir(const Img& imL, const Img& imR)
{
    /*
    void cv::omnidir::stereoReconstruct 	( 	
            
        image1	The first input image
        image2	The second input image
        K1	Input camera matrix of the first camera
        D1	Input distortion parameters (k1,k2,p1,p2) for the first camera
        xi1	Input parameter xi for the first camera for CMei's model
        K2	Input camera matrix of the second camera
        D2	Input distortion parameters (k1,k2,p1,p2) for the second camera
        xi2	Input parameter xi for the second camera for CMei's model
        R	Rotation between the first and second camera
        T	Translation between the first and second camera
        flag	Flag of rectification type, RECTIFY_PERSPECTIVE or RECTIFY_LONGLATI
        numDisparities	The parameter 'numDisparities' in StereoSGBM, see StereoSGBM for details.
        SADWindowSize	The parameter 'SADWindowSize' in StereoSGBM, see StereoSGBM for details.
        disparity	Disparity map generated by stereo matching
        image1Rec	Rectified image of the first image
        image2Rec	rectified image of the second image
        newSize	Image size of rectified image, see omnidir::undistortImage
        Knew	New camera matrix of rectified image, see omnidir::undistortImage
        pointCloud	Point cloud of 3D reconstruction, with type CV_64FC3
        pointType	Point cloud type, it can be XYZRGB or XYZ 	

    */
    cv::Mat imc1 = ImgCv(imL).raw();
    cv::Mat imc2 = ImgCv(imR).raw();

    cv::Size sz = imc1.size();
    CamCfg camc;
    if (!camc.load(lc_.sf_camc))
        return false;
    cv::Mat K; cv::eigen2cv(camc.K, K);
    auto& Dc = camc.D;
    double b = lc_.baseline;
    Mat R = (Mat_<double>(3, 3) << 1, 0, 0,  0, 1, 0, 0, 0, 1);    
    Mat T = (Mat_<double>(3, 1) << b,0,0);    
    Mat D = (Mat_<double>(4, 1) << Dc.k1, Dc.k2, Dc.p1, Dc.p2);    
    Mat imr1, imr2, pointCloud;
    double xi1=1, xi2=1;
    int pointType = omnidir::XYZRGB;
    int numDisparities = 16*5;
    int SADWindowSize = 5;
    int flag = cv::omnidir::RECTIFY_PERSPECTIVE;
    auto Knew = cv::Matx33d(sz.width/4, 0, sz.width/2,
               0, sz.height/4, sz.height/2,
               0, 0, 1);
    cv::Mat imd;
    cv::omnidir::stereoReconstruct(imc1, imc2, 
        K, D, xi1, K, D, xi2, 
        R, T, flag, numDisparities, SADWindowSize, 
        imd, imr1, imr2, sz,  cv::Mat(), pointCloud, pointType);
    cv::imshow("imr1", imr1);
    cv::imshow("imr2", imr2);
    cv::imshow("imd", imd);
    vsn::show_loop();
    return true;
}

//---------------------------
// ref:
//   https://answers.opencv.org/question/223280/calculating-depth-with-ptrstereosgbm-black-bar-on-image/
bool test_LR_ref(const Img& imL, const Img& imR)
{

    // input
    cv::Mat left, right;
    left  = ImgCv(imL).raw();
    right = ImgCv(imR).raw();

    bool no_downscale = true;
    int max_disp = MAX_DISPARITY;
    
    Mat left_for_matcher, right_for_matcher;
    Mat left_disp, right_disp;
    Mat filtered_disp;
    Mat conf_map = Mat(left.rows, left.cols, CV_8U);
    conf_map = Scalar(255);
    cv::Rect ROI;
    Ptr<ximgproc::DisparityWLSFilter> wls_filter;
    double matching_time, filtering_time;

    if (!no_downscale)
    {
        max_disp *= DOWNSCALE;
        if (max_disp % 16 != 0)
            max_disp += 16 - (max_disp % 16);
        resize(left, left_for_matcher, Size(), DOWNSCALE, DOWNSCALE);
        resize(right, right_for_matcher, Size(), DOWNSCALE, DOWNSCALE);
    }
    else
    {
        left_for_matcher = left.clone();
        right_for_matcher = right.clone();
    }

    Ptr<StereoSGBM> left_matcher = StereoSGBM::create(0, max_disp, WIN_SIZE_SGBM);
    left_matcher->setP1(24 * WIN_SIZE_SGBM*WIN_SIZE_SGBM*SMOOTHING_FACTOR);
    left_matcher->setP2(96 * WIN_SIZE_SGBM*WIN_SIZE_SGBM*SMOOTHING_FACTOR);
    left_matcher->setPreFilterCap(MAX_X_GRAD);
    left_matcher->setMode(StereoSGBM::MODE_SGBM_3WAY);
    wls_filter = ximgproc::createDisparityWLSFilter(left_matcher);
    Ptr<StereoMatcher> right_matcher = ximgproc::createRightMatcher(left_matcher);

    matching_time = (double)getTickCount();
    left_matcher->compute(left_for_matcher, right_for_matcher, left_disp);
    right_matcher->compute(right_for_matcher, left_for_matcher, right_disp);
    matching_time = ((double)getTickCount() - matching_time) / getTickFrequency();

    wls_filter->setLambda(LAMBDA);
    wls_filter->setSigmaColor(SIGMA);
    filtering_time = (double)getTickCount();
    wls_filter->filter(left_disp, left, filtered_disp, right_disp);
    filtering_time = ((double)getTickCount() - filtering_time) / getTickFrequency();

    conf_map = wls_filter->getConfidenceMap();

    // Get the ROI that was used in the last filter call:
    if (!no_downscale)
    {
        // upscale raw disparity and ROI back for a proper comparison:
        resize(left_disp, left_disp, Size(), 1 / DOWNSCALE, 1 / DOWNSCALE);
        left_disp = left_disp / DOWNSCALE;
    }



    Mat raw_disp_vis;
    cv::ximgproc::getDisparityVis(left_disp, raw_disp_vis, VIS_MULT);

    Mat filtered_disp_vis;
    cv::ximgproc::getDisparityVis(filtered_disp, filtered_disp_vis, VIS_MULT);

   // return filtered_disp_vis;
    imshow("confmap", conf_map);
    imshow("left", left);
    imshow("right", right);
    imshow("raw disparity vis", raw_disp_vis);
    imshow("filtered disparity vis", filtered_disp_vis);
    vsn::show_loop();
    return true;
}

//------------------
// test_imgLR()
//------------------
bool TestStereo::test_imgLR()const
{
    auto pL = Img::loadFile(lc_.sf_L);
    auto pR = Img::loadFile(lc_.sf_R);
    if(pL==nullptr || pR==nullptr)
        return false;

    auto& imL = *pL;
    auto& imR = *pR;
 // return test_LR_ref(imL, imR);
//  return test_LR(imL, imR);
    return test_LR_omnidir(imL, imR);
    return true;
}
